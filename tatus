diff --git a/SoarRobotServer/src/main/java/edu/umich/robot/network/Server.java b/SoarRobotServer/src/main/java/edu/umich/robot/network/Server.java
index dbc01a6..4b25671 100644
--- a/SoarRobotServer/src/main/java/edu/umich/robot/network/Server.java
+++ b/SoarRobotServer/src/main/java/edu/umich/robot/network/Server.java
@@ -55,6 +55,7 @@ public class Server implements RobotEventListener {
 					try {
 						Socket client = socket.accept();
 						startLCM(client.getInetAddress(), client.getPort());
+						//startLCM(InetAddress.getByName("10.0.2.15"), client.getPort());
 						Scanner scanner = new Scanner(client.getInputStream()).useDelimiter("\n");
 						boolean scanning = true;
                         out = new PrintWriter(client.getOutputStream());
diff --git a/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/network/RobotSession.java b/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/network/RobotSession.java
index 59d0d59..4d222e2 100644
--- a/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/network/RobotSession.java
+++ b/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/network/RobotSession.java
@@ -41,183 +41,250 @@ import edu.umich.soarrobot.SoarRobotTablet.SoarRobotTablet;
 import edu.umich.soarrobot.SoarRobotTablet.layout.MapView;
 import edu.umich.soarrobot.SoarRobotTablet.objects.SimObject;
 
-public class RobotSession extends Thread implements LCMSubscriber {
-	
-	SoarRobotTablet activity;
-	String server;
-	int port;
-	boolean paused;
-	
-	Socket tcpClient;
-	PrintWriter tcpWriter;
-	Scanner tcpScanner;
-	
-	LCM lcm;
-	String lcmConnectionString;
-	ArrayList<String> robotNames;
-	
-	public RobotSession(SoarRobotTablet activity, String server, int port) {
-		this.activity = activity;
-		this.server = server;
-		this.port = port;
-		paused = false;
-		
-		String deviceName = Build.DEVICE;
-		
-		try {
-			tcpClient = new Socket(server, port);
-			tcpWriter = new PrintWriter(tcpClient.getOutputStream());
-			tcpScanner = new Scanner(tcpClient.getInputStream()).useDelimiter("\n");
-			System.out.println("connected to server, local port: " + tcpClient.getLocalPort());
-		} catch (UnknownHostException e) {
-			e.printStackTrace();
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		
-		if (tcpClient == null) {
-			return;
-		}
-
-		robotNames = new ArrayList<String>();
-		tcpListener.start();
-        sendMessage("map");
-        sendMessage("classes");
-        sendMessage("robots");
-        sendMessage("objects");
-		try {
-			// This needs to be the client address.
-			String clientHost;
-			Log.d("BLAH", "deviceName is " + deviceName);
-			if (deviceName.equals("generic")) {
-				clientHost = "/10.0.2.15";
-			} else {
-				clientHost = tcpClient.getLocalAddress().toString();
-			}
-			
-			String clientPort = "" + tcpClient.getLocalPort();
-			lcmConnectionString = "udp:/" + clientHost + ":" + clientPort;
-			lcm = new LCM(lcmConnectionString);
-			for (String robotName : robotNames) {
-				lcm.subscribe("POSE_" + robotName, this);
-			}
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		activity.showAlert("Connected to server at " + server + ":" + port, Toast.LENGTH_LONG);
-		activity.getMapView().draw();
-	}
-	
-	public void sendMessage(String message) {
-		tcpWriter.println(message);
-		tcpWriter.flush();
-	}
-	
-	// Handles a TCP message that was sent from the server.
-	private void handleMessage(String message) {
-	    int space = message.indexOf(' ');
-	    if (space == -1) {
-	        return;
-	    }
-	    String command = message.substring(0, space);
-	    if (command.equals("map")) {
-	        activity.getMapView().deserializeMap(message.substring(space));
-	    }
-	    else if (command.equals("classes")) {
-	        SimObject.init(message.substring(space) + " splinter { }");
-	    }
-	    else if (command.equals("robots")) {
-	        for (String robotString : message.substring(space).split(";")) {
-	            if (robotString.length() == 0) {
-	                continue;
-	            }
-	            Scanner s = new Scanner(robotString).useDelimiter(" ");
-	            String name = s.next();
-	            float x = s.nextFloat();
-	            float y = -s.nextFloat();
-	            float theta = s.nextFloat();
-	            SimObject robot = new SimObject("splinter", new PointF(x, y));
-	            robot.setTheta(theta);
-	            robot.setAttribute("name", name);
-	            activity.getMapView().addRobot(robot);
-	            robotNames.add(name);
-	        }
-	    }
-	    else if (command.equals("objects")) {
-	        for (String objString : message.substring(space).split(";")) {
-	            if (objString.length() == 0) {
-	                continue;
-	            }
-	            Scanner s = new Scanner(objString).useDelimiter(" ");
-	            String name = s.next();
-	            float x = s.nextFloat();
-	            float y = -s.nextFloat();
-	            float theta = s.nextFloat();
-	            SimObject sim = new SimObject(name, new PointF(x, y));
-	            sim.setTheta(theta);
-	            activity.getMapView().addObject(sim);
-	        }
-	    }
-	    else if (command.equals("text")) {
-	        activity.setPropertiesText(message.substring(space));
-	    }
+public class RobotSession extends Thread implements LCMSubscriber
+{
+
+    SoarRobotTablet activity;
+
+    String server;
+
+    int port;
+
+    boolean paused;
+
+    Socket tcpClient;
+
+    PrintWriter tcpWriter;
+
+    Scanner tcpScanner;
+
+    LCM lcm;
+
+    String lcmConnectionString;
+
+    ArrayList<String> robotNames;
+
+    public RobotSession(SoarRobotTablet activity, String server, int port)
+    {
+        synchronized (this)
+        {
+            this.activity = activity;
+            this.server = server;
+            this.port = port;
+            paused = false;
+
+            String deviceName = Build.DEVICE;
+
+            try
+            {
+                tcpClient = new Socket(server, port);
+                tcpWriter = new PrintWriter(tcpClient.getOutputStream());
+                tcpScanner = new Scanner(tcpClient.getInputStream())
+                        .useDelimiter("\n");
+                System.out.println("connected to server, local port: "
+                        + tcpClient.getLocalPort());
+            }
+            catch (UnknownHostException e)
+            {
+                e.printStackTrace();
+            }
+            catch (IOException e)
+            {
+                e.printStackTrace();
+            }
+
+            if (tcpClient == null)
+            {
+                return;
+            }
+
+            robotNames = new ArrayList<String>();
+            tcpListener.start();
+            sendMessage("map");
+            sendMessage("classes");
+            sendMessage("robots");
+            sendMessage("objects");
+            try
+            {
+                // This needs to be the client address.
+                String clientHost;
+                Log.d("BLAH", "deviceName is " + deviceName);
+                if (deviceName.equals("generic"))
+                {
+                    clientHost = "/10.0.2.15";
+                }
+                else
+                {
+                    clientHost = tcpClient.getLocalAddress().toString();
+                }
+
+                String clientPort = "" + tcpClient.getLocalPort();
+                lcmConnectionString = "udp:/" + clientHost + ":" + clientPort;
+                lcm = new LCM(lcmConnectionString);
+                for (String robotName : robotNames)
+                {
+                    lcm.subscribe("POSE_" + robotName, this);
+                }
+            }
+            catch (IOException e)
+            {
+                e.printStackTrace();
+            }
+            activity.showAlert("Connected to server at " + server + ":" + port,
+                    Toast.LENGTH_LONG);
+            activity.getMapView().draw();
+        }
+    }
+
+    public void sendMessage(String message)
+    {
+        tcpWriter.println(message);
+        tcpWriter.flush();
+    }
+
+    // Handles a TCP message that was sent from the server.
+    private void handleMessage(String message)
+    {
+        int space = message.indexOf(' ');
+        if (space == -1)
+        {
+            return;
+        }
+        String command = message.substring(0, space);
+        if (command.equals("map"))
+        {
+            activity.getMapView().deserializeMap(message.substring(space));
+        }
+        else if (command.equals("classes"))
+        {
+            SimObject.init(message.substring(space) + " splinter { }");
+        }
+        else if (command.equals("robots"))
+        {
+            for (String robotString : message.substring(space).split(";"))
+            {
+                if (robotString.length() == 0)
+                {
+                    continue;
+                }
+                Scanner s = new Scanner(robotString).useDelimiter(" ");
+                String name = s.next();
+                float x = s.nextFloat();
+                float y = -s.nextFloat();
+                float theta = s.nextFloat();
+                SimObject robot = new SimObject("splinter", new PointF(x, y));
+                robot.setTheta(theta);
+                robot.setAttribute("name", name);
+                activity.getMapView().addRobot(robot);
+                robotNames.add(name);
+                if (lcm != null)
+                {
+                    lcm.subscribe("POSE_" + name, this);
+                }
+            }
+        }
+        else if (command.equals("objects"))
+        {
+            for (String objString : message.substring(space).split(";"))
+            {
+                if (objString.length() == 0)
+                {
+                    continue;
+                }
+                Scanner s = new Scanner(objString).useDelimiter(" ");
+                String name = s.next();
+                float x = s.nextFloat();
+                float y = -s.nextFloat();
+                float theta = s.nextFloat();
+                SimObject sim = new SimObject(name, new PointF(x, y));
+                sim.setTheta(theta);
+                activity.getMapView().addObject(sim);
+            }
+        }
+        else if (command.equals("text"))
+        {
+            activity.setPropertiesText(message.substring(space));
+        }
         MapView mv = activity.getMapView();
-        if (mv != null) {
+        if (mv != null)
+        {
             mv.draw();
         }
     }
-	
-	// Handles a UDP message that was sent from the server.
-	@Override
-	public void messageReceived(LCM lcm, String channel, LCMDataInputStream ins) {
-		try {
-			pose_t p = new pose_t(ins);
-			PointF robotLocation = new PointF((float)p.pos[0], -(float)p.pos[1]);
-
-			float theta = (float) (LinAlg.quatToRollPitchYaw(p.orientation)[2] * 180.0f / Math.PI);
-			SimObject robot = activity.getMapView().getRobot(channel.split("_")[1]);
-			if (robot != null) {
-				robot.setLocation(robotLocation);
-				robot.setTheta(theta);
-			}
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		MapView mv = activity.getMapView();
-		if (mv != null) {
-			mv.draw();
-		}
-	}
-	
-	public void pause() {
-		paused = true;
-		if (lcm != null) {
-			lcm.close();
-			lcm = null;
-		}
-	}
-	
-	public void unPause() {
-		paused = false;
-		if (lcmConnectionString == null) {
-			return;
-		}
-		try {
-			lcm = new LCM(lcmConnectionString);
-			for (String robotName : robotNames) {
-				lcm.subscribe("POSE_" + robotName, this);
-			}
-		} catch (IOException e) {
+
+    // Handles a UDP message that was sent from the server.
+    @Override
+    public void messageReceived(LCM lcm, String channel, LCMDataInputStream ins)
+    {
+        try
+        {
+            pose_t p = new pose_t(ins);
+            PointF robotLocation = new PointF((float) p.pos[0],
+                    -(float) p.pos[1]);
+
+            float theta = (float) (LinAlg.quatToRollPitchYaw(p.orientation)[2] * 180.0f / Math.PI);
+            SimObject robot = activity.getMapView().getRobot(
+                    channel.split("_")[1]);
+            if (robot != null)
+            {
+                robot.setLocation(robotLocation);
+                robot.setTheta(theta);
+            }
+        }
+        catch (IOException e)
+        {
             e.printStackTrace();
         }
+        MapView mv = activity.getMapView();
+        if (mv != null)
+        {
+            mv.draw();
+        }
     }
-	
-	public Thread tcpListener = new Thread() {
-	    public void run() {
-	        while(true) {
-	            String message = tcpScanner.next();
-	            RobotSession.this.handleMessage(message);
-	        }
-	    };
-	};
-}
\ No newline at end of file
+
+    public void pause()
+    {
+        paused = true;
+        if (lcm != null)
+        {
+            lcm.close();
+            lcm = null;
+        }
+    }
+
+    public void unPause()
+    {
+        paused = false;
+        if (lcmConnectionString == null)
+        {
+            return;
+        }
+        try
+        {
+            lcm = new LCM(lcmConnectionString);
+            for (String robotName : robotNames)
+            {
+                lcm.subscribe("POSE_" + robotName, this);
+            }
+        }
+        catch (IOException e)
+        {
+            e.printStackTrace();
+        }
+    }
+
+    public Thread tcpListener = new Thread()
+    {
+        public void run()
+        {
+            while (true)
+            {
+                synchronized (RobotSession.this)
+                {
+                    String message = tcpScanner.next();
+                    RobotSession.this.handleMessage(message);
+                }
+            }
+        };
+    };
+}
diff --git a/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/objects/SimObject.java b/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/objects/SimObject.java
index f18f4f2..046415e 100644
--- a/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/objects/SimObject.java
+++ b/SoarRobotTablet/src/edu/umich/soarrobot/SoarRobotTablet/objects/SimObject.java
@@ -21,7 +21,7 @@
  */
 
 /**
- * This class handles the representation of objects in the simulation.
+ * a=This class handles the representation of objects in the simulation.
  * Because the definitions for the different types of objects are sent
  * to us over the network when the simulation begins, we can't hard-code
  * those definitions into this class -- we need to be more flexible.
